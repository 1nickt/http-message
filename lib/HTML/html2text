#!/local/bin/perl
# $Id: html2text,v 1.3 1995/09/12 08:50:22 aas Exp $


use HTML::Parse;

$file = shift || "test.html";

$h = parse_htmlfile $file;
#print $h->asHTML, "\n";

package HTML::Format;

$lm  =    3;  # left margin
$rm  =   70;  # right margin
$pos =    0;  # current output position.
$maxpos = 0;  # highest value of $pos

@ignore = (); # just a place to collect unknown tags, so that we can
              # report this as errors at the end.

$main::h->traverse(\&visit);

sub visit
{
    my($node, $start, $depth) = @_;
    if (ref $node) {
	my $tag = $node->tag;
	my $func = $tag . '_' . ($start ? "start" : "end");
	if (defined &$func) {
	    return &$func($node);
	} else {
	    push(@ignore, $func);
	    return 0;
	}
    } else {
	textflow($node);
    }
    1;
}

sub vspace;
sub out;

sub html_start { 1; }  sub html_end {}
sub head_start { 0; }
sub body_start { 1; }  sub body_end {}

sub header_start
{
    my($level, $node) = @_;
    vspace(2);
    $maxpos = 0;
    $eat_leading_space = 1;
    1;
}

sub header_end
{
    my($level, $node) = @_;
    if ($level <= 2) {
	my $line;
	$line = '=' if $level == 1;
	$line = '-' if $level == 2;
	vspace(0);
	out $line x ($maxpos - $lm);
    }
    vspace 1;
    1;
}

sub h1_start { header_start(1, @_) }
sub h2_start { header_start(2, @_) }
sub h3_start { header_start(3, @_) }
sub h4_start { header_start(4, @_) }
sub h5_start { header_start(5, @_) }
sub h6_start { header_start(6, @_) }

sub h1_end   { header_end(1, @_) }
sub h2_end   { header_end(2, @_) }
sub h3_end   { header_end(3, @_) }
sub h4_end   { header_end(4, @_) }
sub h5_end   { header_end(5, @_) }
sub h6_end   { header_end(6, @_) }

sub br_start
{
    vspace(0);
}

sub hr_start
{
    vspace(1);
    out '-' x ($rm - $lm);
    vspace(1);
}

sub img_start
{
    out(shift->attr('alt') || "[IMAGE]");
}

sub a_start
{
    $anchor++;
    1;
}

sub a_end
{
    $anchor--;
}

sub u_start
{
    $underline++;
    1;
}

sub u_end
{
    $underline--;
}

sub b_start
{
    $bold++;
    1;
}

sub b_end
{
    $bold--;
}

sub tt_start
{
    $teletype++;
    1;
}

sub tt_end
{
    $teletype--;
}

sub i_start
{
    $italic++;
    1;
}

sub i_end
{
    $italic--;
}

sub center_start
{
    $center++;
}

sub center_end
{
    $center--;
}

# Logical markup
BEGIN {
    *cite_start   = \&i_start;
    *cite_end     = \&i_end;
    *code_start   = \&tt_start;
    *code_end     = \&tt_end;
    *em_start     = \&i_start;
    *em_end       = \&i_end;
    *kbd_start    = \&tt_start;
    *kbd_end      = \&tt_end;
    *samp_start   = \&tt_start;
    *samp_end     = \&tt_end;
    *strong_start = \&b_start;
    *strong_end   = \&b_end;
    *var_start    = \&tt_start;
    *var_end      = \&tt_end;
}

sub p_start
{
    vspace(1);
    $eat_leading_space = 1;
    1;
}

sub p_end
{
    vspace(1);
}

sub pre_start
{
    $pre++;
    vspace(1);
    1;
}

sub pre_end
{
    $pre--;
    vspace(1);
}

BEGIN {
    *listing_start = \&pre_start;
    *listing_end   = \&pre_end;
    *xmp_start     = \&pre_start;
    *xmp_end       = \&pre_end;
}

sub blockquote_start
{
    vspace(1);
    $eat_leading_space = 1;
    $lm += 2;
    $rm -= 2;
    1;
}

sub blockquote_end
{
    $lm -= 2;
    $rm += 2;
    vspace(1);
}

sub address_start
{
    vspace(1);
    $eat_leading_space = 1;
    $italic++;
    1;
}

sub address_end
{
    $italic--;
    vspace(1);
}


# Handling of list elements
BEGIN {
    @markers = ();
}

sub ul_start
{
    vspace(1);
    push(@markers, "*");
    $lm += 2;
    1;
}

sub ul_end
{
    pop(@markers);
    $lm -= 2;
    vspace(1);
}

sub li_start
{
    out "$markers[-1] ";
    $lm += 2;
    $eat_leading_space = 1;
    1;
}

sub li_end
{
    vspace 1;
    $lm -= 2;
    if ($markers[-1] =~ /^\d+/) {
	# increment ordered markers
	$markers[-1]++;
    }
}

sub ol_start
{
    vspace 1;
    push(@markers, 1);
    $lm += 2;
    1;
}

sub ol_end
{
    $lm -= 2;
    pop(@markers);
    vspace 1;
}


sub dl_start
{
    vspace 1;
    $lm += 2;
    1;
}

sub dl_end
{
    vspace 1;
    $lm -= 2;
}

sub dt_start
{
    vspace(1);
    $eat_leading_space = 1;
    1;
}

sub dt_end
{
}

sub dd_start
{
    $lm += 6;
    vspace(0);
    $eat_leading_space = 1;
    1;
}

sub dd_end
{
    $lm -= 6;
}


# Things not formated at all
sub table_start { out "[TABLE NOT SHOWN]"; 0; }
sub form_start  { 0; }
sub font_start  { 1; }  sub font_end {}



sub textflow
{
    if ($pre) {
	pre_out($_[0]);
    } else {
	for (split(/(\s+)/, $_[0])) {
	    out $_ if length $_;
	}
    }
}


sub pre_out
{
    # should really handle bold/italic etc.
    if (defined $vspace) {
	if ($out) {
	    nl();
	    nl() while $vspace-- > 0;
	    $vspace = undef;
	}
    }
    my $indent = ' ' x $lm;
    my $pre = shift;
    $pre =~ s/^/$indent/gm;
    print $pre;
    $out++;
}

sub out
{
    my $text = shift;

    if (defined $vspace) {
	if ($out) {
	    nl();
	    nl() while $vspace-- > 0;
	    lm();
	} else {
	    lm();
	}
	$vspace = undef;
    }

    if ($eat_leading_space) {
	$text =~ s/^\s+//;
	$eat_leading_space = 0;
    }

    if ($pos > $rm) {  # line is long enogh, break it
	return if $text =~ /^\s*$/;  # white space at eol is ok
	nl(); lm();
    }
    
    if ($pending_space) {
	$pending_space = 0;
	print ' ';
	$pos++;
	$maxpos = $pos if $maxpos < $pos;
    }

    $pending_space = 1 if $text =~ s/\s+$//;
    return unless length $text;

    print $text;
    $pos += length $text;
    $maxpos = $pos if $maxpos < $pos;
    $out++;
}

sub vspace
{
    my $new = shift;
    return if defined $vspace and $vspace > $new;
    $vspace = $new;
}


sub lm
{
    if ($pos < $lm) {
	print " " x ($lm - $pos);
	$pos = $lm;
    }
}

sub nl
{
    print "\n";
    $out++;
    $pending_space = 0;
    $pos = 0;
}

END
{
    print "\n";
    if (@ignore) {
	print "Ignored tags:\n";
	for (@ignore) {
	    print "\t$_\n";
	}
    }
}
